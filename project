#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>
#include <utility>
#include <set>
#include <fstream>
#include <sstream>

using namespace std;

class AdjacencyList {
    unordered_map<string, vector<pair <string, int> > > list;
    unordered_map<string, vector<pair <string, int> > > lyft;
    unordered_map<string, vector<pair <string, int> > > uber;
    set<string> vertices;

public:
    void insertLyft(string from, string to, double price); //populate lyft map
    void insertUber(string from, string to, double price); //populate uber map
    void printLyft(); //checking if everything is loaded properly
    void printUber(); //checking if everything is loaded properly
    void getDestinations(string location);
    void BuildGraph();
};

void AdjacencyList::insertLyft(string from, string to, double price)
{
    lyft[from].push_back(make_pair(to, price));
    lyft[to].push_back(make_pair(from, price));
}

void AdjacencyList::insertUber(string from, string to, double price)
{
    uber[from].push_back(make_pair(to, price));
    uber[to].push_back(make_pair(from, price));
}

void AdjacencyList::printLyft() //checking if the maps were made properly
{
    for (auto it : lyft)
    {
        for (auto ve : it.second)
        {
            cout << it.first << "," << ve.first << "," << ve.second << "\n";
        }

    }
}

void AdjacencyList::printUber() //checking if the maps were made properly
{
    for (auto it : uber)
    {
        for (auto ve : it.second)
        {
            cout << it.first << "," << ve.first << "," << ve.second << "\n";
        }

    }
}

void heapify(vector<pair<string, int> >& v, int n, int start)
{
    int big = start;
    int left = 2*start + 1;
    int right = 2*start + 2;

    if (left < n && v[left].second > v[big].second) {
        big = left;
    }

    if (right < n && v[right].second > v[big].second) {
        big = right;
    }

    if (big != start) {
        swap(v[start], v[big]);
        heapify(v, n, big);
    }
}
void buildHeap(vector<pair<string, int> >& v, int size) {
    for (int i = size / 2 - 1; i >= 0; i--) {
        heapify(v, size, i);
    }
}
void heapSort(vector<pair<string, int> >& v)
{
    int size = v.size();
    buildHeap(v, size);
    for (int i = size - 1; i > 0; i--) {
        swap(v[0], v[i]);
        heapify(v, i, 0);
    }
}
void superSort(vector<pair<string, int> >& v) {
    bool sorted = true;
    for(int i = 0; i < v.size()-1; i++) {
        if(v[i] > v[i+1]) {
            sorted = false;
        }
    }
    if(sorted) {
        cout << "sorted!" << endl;
        return;
    }

    heapSort(v);
}
void AdjacencyList::getDestinations(string location) {
    vector<pair<string, int> > destinations = list[location];
    superSort(destinations);
    for(int i = 0; i < destinations.size(); i++) {
        cout << "Possible Destination: " << destinations[i].first << " Price: $" << destinations[i].second << endl;
    }
}

int main()
{
    string start, end;
    AdjacencyList graph;
    cout << "Please enter your current location.\n";
    getline(cin, start);
    cout << "Please enter your destination. Type 'random' if you would like us to choose.\n";
    getline(cin, end);
    ifstream file("data.txt");

    if (!file.is_open()) {
        cout << "file could not be opened";
    }

    if (file)
    {
        string type, from, to, line, extra, p;
        double price;

        while (getline(file, line))
        {
            stringstream linestream(line);

            getline(linestream, extra, ',');
            getline(linestream, type, ',');
            getline(linestream, extra, ',');
            getline(linestream, to, ',');
            getline(linestream, from, ',');
            getline(linestream, p, ',');
            getline(linestream, extra, ',');
            getline(linestream, extra, ',');
            getline(linestream, extra, ',');
            getline(linestream, extra, ',');

            if (p == "") //there's some that have the price field blank
                p = "0";

            //cout << type << " " << p << "\n";

            price = stod(p);

            if (type == "Lyft")
                graph.insertLyft(from, to, price);

            else
                graph.insertUber(from, to, price);

        }
    }

    file.close();
    graph.printLyft();
    graph.printUber();

    return 0;
}
